<div class="min-h-screen bg-gray-900 text-gray-100 flex items-center justify-center p-4">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#6366f1',
                        'secondary': '#8b5cf6',
                        'dark-bg': '#1f2937',
                        'dark-card': '#374151',
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar for chat box */
        #chat-box::-webkit-scrollbar {
            width: 8px;
        }

        #chat-box::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }

        #chat-box::-webkit-scrollbar-track {
            background-color: #1f2937;
        }
    </style>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, serverTimestamp, setLogLevel, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- USER-PROVIDED FIREBASE CONFIG ---
        const hardcodedFirebaseConfig = {
            apiKey: "AIzaSyCDu1T73_HOaxC5gtHTNHev8HIfPSwbsqc",
            authDomain: "knokbak-message-panel.firebaseapp.com",
            projectId: "knokbak-message-panel",
            storageBucket: "knokbak-message-panel.firebasestorage.app",
            messagingSenderId: "424259711684",
            appId: "1:424259711684:web:6818525d64024815604f91"
        };
        
        // Global Variables
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // **Firebase Config setup**
        let firebaseConfig;
        try {
            // Check for environment configuration first
            const envConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
            const parsedConfig = JSON.parse(envConfig);
            // Use environment config if valid, otherwise use the user-provided hardcoded config
            firebaseConfig = (parsedConfig && parsedConfig.apiKey) ? parsedConfig : hardcodedFirebaseConfig;
        } catch (e) {
            console.warn("Could not parse environment Firebase config. Using user-provided config.");
            firebaseConfig = hardcodedFirebaseConfig;
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app;
        let db;
        let auth;
        let currentUserId = null;
        let currentUserData = null; // Stores user profile data
        let currentServerId = 'global'; 
        let unsubscribeMessages = null;
        let unsubscribeUsers = null;
        let isAdmin = false;
        let isAuthReady = false;

        // Admin ID must be the specific UID obtained from the console after the first admin login
        // For simplicity in a public chat, let's use a non-default identifier for the admin logic
        const ADMIN_ID = "YOUR_SPECIFIC_ADMIN_UID"; // <-- Update this if you need an admin user
        
        // These collections must be writable by authenticated users (including anonymous)
        // Public data path: /artifacts/{appId}/public/data/{your_collection_name}
        const MESSAGES_COLLECTION_PATH = `/artifacts/${appId}/public/data/messages`;
        const ANONYMOUS_USERS_COLLECTION_PATH = `/artifacts/${appId}/public/data/anonymous_users`; 
        
        // --- Utility Functions ---

        // Simple debounce function to limit function calls
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        }

        function escapeHTML(str) {
            return str.replace(/&/g, '&amp;')
                      .replace(/</g, '&lt;')
                      .replace(/>/g, '&gt;')
                      .replace(/"/g, '&quot;')
                      .replace(/'/g, '&#039;');
        }

        // --- Auth and Init (Simplified) ---

        function updateLoadingStatus(message) {
            const statusElement = document.getElementById('loading-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        function showMessageBox(title, message, duration = 3000, bgColor = 'bg-gray-700') {
            const container = document.getElementById('message-box-container');
            const messageBox = document.createElement('div');
            
            messageBox.className = `fixed bottom-4 right-4 z-50 p-4 rounded-lg shadow-xl text-white transition-opacity duration-300 ${bgColor}`;
            messageBox.innerHTML = `
                <div class="font-bold">${title}</div>
                <div class="text-sm">${message}</div>
            `;
            container.appendChild(messageBox);

            setTimeout(() => {
                messageBox.classList.add('opacity-0');
                messageBox.addEventListener('transitionend', () => messageBox.remove());
            }, duration);
        }

        async function initFirebase() {
            try {
                setLogLevel('error'); 
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Set session persistence to keep the anonymous user signed in across browser sessions
                await setPersistence(auth, browserSessionPersistence);
                
                updateLoadingStatus("Signing in anonymously...");

                // Immediately sign in anonymously for instant access
                // If a user is already signed in (due to session persistence), this call is usually idempotent or fast.
                if (!auth.currentUser) {
                    await signInAnonymously(auth);
                }

                // Wait for auth state to be resolved
                onAuthStateChanged(auth, (user) => {
                    isAuthReady = true;
                    if (user) {
                        currentUserId = user.uid;
                        handleSuccessfulAuth(); 
                    } else {
                        currentUserId = null;
                        updateLoadingStatus("Authentication Failed. Cannot access chat (Auth Error).");
                        // If auth fails, show the full error screen
                        document.getElementById('loading-overlay').classList.remove('hidden');
                        document.getElementById('app-container').classList.add('hidden');
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                updateLoadingStatus(`Initialization Error: ${error.message}`);
                showMessageBox("Error", `Firebase init failed: ${error.message}`, 8000, 'bg-red-500');
            }
        }

        async function createOrFetchAnonymousUserProfile() {
            if (!currentUserId || !db) return false;
            
            updateLoadingStatus("Fetching user profile...");

            const userDocRef = doc(db, ANONYMOUS_USERS_COLLECTION_PATH, currentUserId);
            try {
                const docSnap = await getDoc(userDocRef);
                
                if (docSnap.exists()) {
                    currentUserData = docSnap.data();
                    isAdmin = currentUserData.isAdmin || false;
                } else {
                    // If it's a new anonymous user, create a default profile
                    const randomName = `AnonUser${Math.floor(1000 + Math.random() * 9000)}`;
                    const tag = Math.floor(1000 + Math.random() * 9000).toString();
                    const newProfile = {
                        userId: currentUserId,
                        username: randomName,
                        tag: tag,
                        pfpUrl: `https://placehold.co/80x80/${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}/ffffff?text=${randomName.charAt(0)}`,
                        isAdmin: currentUserId === ADMIN_ID,
                        lastOnline: serverTimestamp(),
                        isAnonymous: true
                    };
                    await setDoc(userDocRef, newProfile);
                    currentUserData = newProfile;
                    isAdmin = newProfile.isAdmin;
                }
                // Update last online timestamp every time we load
                await updateDoc(userDocRef, { lastOnline: serverTimestamp() });
                return true;
            } catch (e) {
                console.error("Error creating/fetching anonymous profile:", e);
                updateLoadingStatus(`Profile Error (Check Rules for ${ANONYMOUS_USERS_COLLECTION_PATH}): ${e.message}`);
                showMessageBox("Profile Error", "Could not access user profiles. Check Firestore rules.", 8000, 'bg-red-700');
                return false;
            }
        }

        async function handleSuccessfulAuth() {
            if (!currentUserId) return;

            // 1. Fetch or create the user's profile
            const profileReady = await createOrFetchAnonymousUserProfile();
            
            if (profileReady && currentUserData) {
                updateLoadingStatus("Profile loaded. Starting chat listeners...");
                document.getElementById('app-container').classList.remove('hidden');
                document.getElementById('loading-overlay').classList.add('hidden');
                setupListeners();
                updateProfileDisplay();
            } else {
                 updateLoadingStatus("Could not load profile. Check Firestore/Network connection.");
            }
        }
        
        // --- Firestore Listeners ---

        function setupListeners() {
            // Stop existing listeners first
            if (unsubscribeMessages) unsubscribeMessages();
            if (unsubscribeUsers) unsubscribeUsers();
            
            // Check for auth readiness before querying
            if (!isAuthReady || !currentUserId) {
                console.warn("Attempted to set up listeners before auth was ready.");
                return;
            }
            
            // Clear message box and reset status display
            const chatBox = document.getElementById('chat-box');
            chatBox.innerHTML = '<div class="text-center text-gray-500 py-4">Fetching messages...</div>';


            // 1. Messages Listener
            const messagesRef = collection(db, MESSAGES_COLLECTION_PATH);
            const messagesQuery = query(messagesRef, where('serverId', '==', currentServerId));

            unsubscribeMessages = onSnapshot(messagesQuery, (snapshot) => {
                const messages = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    messages.push({ ...data, id: doc.id, timestamp: data.timestamp ? data.timestamp.toDate() : new Date() });
                });
                // Sort messages by timestamp
                messages.sort((a, b) => a.timestamp - b.timestamp);
                renderMessages(messages);
            }, (error) => {
                // If this is the source of the insufficient permissions error, it will log here and update the UI.
                console.error("Error fetching messages (Permissions Issue):", error);
                const chatBox = document.getElementById('chat-box');
                chatBox.innerHTML = `
                    <div class="text-center bg-red-800 p-4 rounded-xl text-white font-semibold mx-4 mt-4">
                        <p class="text-xl mb-2">ACCESS DENIED: PERMISSIONS ERROR</p>
                        <p class="text-sm">Cannot read messages from Firestore. This is typically caused by security rules.</p>
                        <p class="text-xs mt-2 font-mono">Check that **authenticated** users (including anonymous) have **read** access to:</p>
                        <p class="text-sm font-mono mt-1 break-all">${MESSAGES_COLLECTION_PATH}</p>
                    </div>
                `;
                showMessageBox("Permissions Error", "Could not fetch messages. Check Firestore rules.", 8000, 'bg-red-700');
            });

            // 2. Users Listener
            const usersRef = collection(db, ANONYMOUS_USERS_COLLECTION_PATH);
            
            unsubscribeUsers = onSnapshot(usersRef, (snapshot) => {
                const users = [];
                snapshot.forEach(doc => {
                    users.push({ ...doc.data(), id: doc.id });
                });
                renderUserList(users);
            }, (error) => {
                console.error("Error fetching users:", error);
            });
            
             // 3. User Presence/Online Status (Debounced Update)
             const updateOnlineStatus = debounce(async (isOnline) => {
                if (currentUserId && db && currentUserData) {
                    try {
                        await updateDoc(doc(db, ANONYMOUS_USERS_COLLECTION_PATH, currentUserId), {
                            lastOnline: isOnline ? serverTimestamp() : Date.now(),
                            isOnline: isOnline 
                        });
                    } catch (e) {
                        // console.error("Failed to update presence:", e); // Suppress frequent errors
                    }
                }
            }, 5000); // 5-second debounce

            // Update status on load/active
            updateOnlineStatus(true);
            
            // Add global event listeners for presence tracking
            window.addEventListener('focus', () => updateOnlineStatus(true));
            window.addEventListener('blur', () => updateOnlineStatus(false));
            window.addEventListener('beforeunload', () => updateOnlineStatus(false));
        }

        // --- Message Handling ---

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const content = input.value.trim();
            if (!content || !currentUserId || !currentUserData) {
                if (!currentUserData) showMessageBox("Error", "Profile still loading. Please wait.", 3000, 'bg-red-500');
                return;
            }

            const message = {
                userId: currentUserId,
                username: currentUserData.username,
                tag: currentUserData.tag,
                content: content,
                pfpUrl: currentUserData.pfpUrl,
                serverId: currentServerId, // Currently 'global'
                timestamp: serverTimestamp()
            };

            try {
                // Note: This collection must be publicly writable by authenticated users
                await addDoc(collection(db, MESSAGES_COLLECTION_PATH), message);
                input.value = ''; // Clear input on success
            } catch (error) {
                console.error("Error sending message (Permissions Issue):", error);
                showMessageBox("Permissions Error", "Failed to send message. Check console. Database rules likely blocking write access to messages.", 8000, 'bg-red-700');
            }
        }
        
        // Allows sending message via ENTER key
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('message-input');
            if (input) {
                input.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }
        });


        function renderMessages(messages) {
            const chatBox = document.getElementById('chat-box');
            // If the chat box already contains a permission error message, don't overwrite it with messages
            if (chatBox.querySelector('.bg-red-800')) return;

            let wasScrolledToBottom = chatBox.scrollHeight - chatBox.clientHeight <= chatBox.scrollTop + chatBox.clientHeight * 0.1; // Check if near bottom

            chatBox.innerHTML = ''; // Clear previous messages

            messages.forEach(msg => {
                const isMine = msg.userId === currentUserId;
                const messageHtml = `
                    <div class="flex items-start space-x-3 p-2 hover:bg-gray-800 transition-colors">
                        <img src="${msg.pfpUrl}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/6B7280/ffffff?text=U'" class="w-10 h-10 rounded-full flex-shrink-0">
                        <div class="flex flex-col w-full">
                            <div class="flex items-baseline space-x-2">
                                <span class="text-sm font-semibold ${isMine ? 'text-primary' : 'text-blue-400'}">${msg.username}</span>
                                <span class="text-xs text-gray-500">#${msg.tag}</span>
                                <span class="text-xs text-gray-500">${msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '...'}</span>
                                ${isAdmin ? `<button onclick="window.deleteMessage('${msg.id}')" class="text-red-500 hover:text-red-400 text-xs ml-auto">Delete</button>` : ''}
                            </div>
                            <p class="text-sm text-gray-300 break-words whitespace-pre-wrap">${escapeHTML(msg.content)}</p>
                        </div>
                    </div>
                `;
                chatBox.insertAdjacentHTML('beforeend', messageHtml);
            });

            // Scroll to bottom only if the user was already near the bottom
            if (wasScrolledToBottom) {
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }
        
        // Expose deleteMessage function globally for inline click handler
        window.deleteMessage = async function(messageId) {
            if (!isAdmin || !messageId) {
                 showMessageBox("Permission Denied", "Only administrators can delete messages.", 3000, 'bg-red-500');
                 return;
            }
            
            showModal('confirmationModal', 'Are you sure you want to delete this message?', () => confirmDelete(messageId));
        }
        
        async function confirmDelete(messageId) {
            closeModal('confirmationModal');
            try {
                await deleteDoc(doc(db, MESSAGES_COLLECTION_PATH, messageId));
                showMessageBox("Success", "Message deleted.", 2000, 'bg-green-600');
            } catch (error) {
                console.error("Error deleting message:", error);
                showMessageBox("Error", "Failed to delete message. Check Firestore rules for write access.", 3000, 'bg-red-500');
            }
        }
        
        // --- User List and Profile UI ---

        function renderUserList(users) {
            const userList = document.getElementById('user-list');
            userList.innerHTML = '';
            
            // Separate online and offline users
            const now = Date.now();
            // A user is considered online if they updated their timestamp in the last 30 seconds
            const onlineUsers = users.filter(u => u.isOnline === true || (u.lastOnline && (now - (u.lastOnline.toMillis ? u.lastOnline.toMillis() : u.lastOnline)) < 30000));
            const offlineUsers = users.filter(u => !u.isOnline || (u.lastOnline && (now - (u.lastOnline.toMillis ? u.lastOnline.toMillis() : u.lastOnline)) >= 30000));

            // Sort by username
            onlineUsers.sort((a, b) => a.username.localeCompare(b.username));
            offlineUsers.sort((a, b) => a.username.localeCompare(b.username));
            
            const renderUser = (user, isOnline) => {
                 const statusColor = isOnline ? 'bg-green-500' : 'bg-gray-500';
                 const statusText = isOnline ? 'Online' : 'Offline';
                 const isSelf = user.userId === currentUserId;
                 const adminBadge = user.isAdmin ? '<span class="text-xs font-bold text-red-400">ADMIN</span>' : '';
                 
                 return `
                    <div class="flex items-center p-2 rounded-lg hover:bg-gray-700 transition-colors ${isSelf ? 'bg-gray-700' : ''}">
                        <div class="relative mr-3">
                            <img src="${user.pfpUrl}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/6B7280/ffffff?text=U'" class="w-8 h-8 rounded-full">
                            <span class="absolute bottom-0 right-0 w-2.5 h-2.5 ${statusColor} rounded-full border-2 border-gray-800" title="${statusText}"></span>
                        </div>
                        <div class="flex flex-col min-w-0">
                            <div class="flex items-center space-x-1 min-w-0">
                                <span class="text-sm font-medium text-gray-200 truncate">${user.username}</span>
                                ${adminBadge}
                            </div>
                            <span class="text-xs text-gray-500">#${user.tag}</span>
                        </div>
                    </div>
                 `;
            };

            const appendGroup = (title, list, isOnline) => {
                if (list.length > 0) {
                     userList.insertAdjacentHTML('beforeend', `<h3 class="text-xs font-semibold text-gray-400 uppercase mt-4 mb-2 px-2">${title} - ${list.length}</h3>`);
                     list.forEach(user => userList.insertAdjacentHTML('beforeend', renderUser(user, isOnline)));
                }
            };
            
            appendGroup('Online', onlineUsers, true);
            appendGroup('Offline', offlineUsers, false);

            document.getElementById('user-count').textContent = users.length;
        }

        function updateProfileDisplay() {
            if (!currentUserData) return;
            const profileDisplay = document.getElementById('profile-display');
            
            profileDisplay.innerHTML = `
                <div class="flex items-center space-x-3">
                    <img src="${currentUserData.pfpUrl}" onerror="this.onerror=null;this.src='https://placehold.co/80x80/6B7280/ffffff?text=U'" class="w-10 h-10 rounded-full">
                    <div class="flex flex-col">
                        <span class="text-base font-semibold text-primary">${currentUserData.username}</span>
                        <span class="text-xs text-gray-400">#${currentUserData.tag}</span>
                    </div>
                </div>
                <div class="text-xs text-gray-500 mt-2 p-1 bg-gray-700/50 rounded-md truncate">
                    Your UID: ${currentUserId}
                </div>
            `;
        }
        
        // --- Modals ---
        let modalCallback = null;

        function showModal(modalId, message, callback) {
            const modal = document.getElementById(modalId);
            const modalMessage = document.getElementById(`${modalId}-message`);
            
            modalMessage.textContent = message;
            modalCallback = callback;
            modal.classList.remove('hidden');
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.classList.add('hidden');
            modalCallback = null;
        }
        
        window.confirmAction = function() {
            if (modalCallback) {
                modalCallback();
            }
            closeModal('confirmationModal');
        }

        window.cancelAction = function() {
            closeModal('confirmationModal');
        }

        // --- Init Call ---
        window.onload = initFirebase;
    </script>

    <!-- Chat Application Layout -->
    <div id="loading-overlay" class="fixed inset-0 flex flex-col items-center justify-center bg-gray-900 z-50 transition-opacity duration-500">
        <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-700 h-12 w-12 mb-4"></div>
        <p id="loading-status" class="text-gray-400">Initializing Firebase...</p>
        <style>
            .loader {
                border-top-color: #6366f1;
                -webkit-animation: spinner 1.5s linear infinite;
                animation: spinner 1.5s linear infinite;
            }
            @-webkit-keyframes spinner { 0% { -webkit-transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); } }
            @keyframes spinner { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        </style>
    </div>

    <div id="app-container" class="hidden w-full max-w-5xl h-[90vh] flex bg-dark-bg rounded-xl shadow-2xl overflow-hidden">
        
        <!-- Sidebar (User List) -->
        <div class="w-1/4 bg-gray-800 p-4 flex flex-col hidden sm:flex">
            <h2 class="text-lg font-bold text-white mb-4">Users (<span id="user-count">0</span>)</h2>
            <div id="user-list" class="flex-grow overflow-y-auto space-y-1">
                <!-- User items will be rendered here -->
            </div>
            
            <!-- Profile Footer -->
            <div id="profile-display" class="mt-4 p-3 bg-gray-900 rounded-lg shadow-inner">
                <!-- Profile details will be rendered here -->
            </div>
        </div>

        <!-- Chat Area -->
        <div class="w-full sm:w-3/4 flex flex-col">
            <!-- Header -->
            <header class="bg-gray-800 p-3 border-b border-gray-700 shadow-md">
                <h1 class="text-xl font-extrabold text-primary">
                    <span class="text-secondary">#</span>GLOBAL-CHAT
                </h1>
            </header>

            <!-- Messages Box -->
            <div id="chat-box" class="flex-grow overflow-y-auto p-4 space-y-3 bg-gray-900">
                <!-- Messages will be rendered here -->
            </div>

            <!-- Input Area -->
            <div class="p-4 bg-gray-800 border-t border-gray-700">
                <div class="flex space-x-3">
                    <input type="text" id="message-input" placeholder="Type a message and press Enter..." 
                           class="flex-grow p-3 rounded-xl bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-primary placeholder-gray-400 transition-colors"
                           maxlength="500">
                    <button onclick="sendMessage()"
                            class="bg-primary hover:bg-secondary text-white font-bold py-3 px-6 rounded-xl transition-all duration-200 transform hover:scale-[1.02] shadow-lg shadow-primary/30">
                        Send
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Toast Message Container -->
    <div id="message-box-container" class="fixed bottom-0 right-0 p-4 space-y-2 z-50"></div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="fixed inset-0 bg-black bg-opacity-70 hidden z-[100] flex items-center justify-center">
        <div class="bg-dark-card p-6 rounded-xl shadow-2xl w-full max-w-sm text-center border border-gray-700">
            <p id="confirmationModal-message" class="text-lg font-semibold text-gray-100 mb-6">Are you sure?</p>
            <div class="flex justify-center space-x-4">
                <button onclick="confirmAction()" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Yes, Delete
                </button>
                <button onclick="cancelAction()" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>
</div>